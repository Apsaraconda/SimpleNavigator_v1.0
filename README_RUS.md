# SimpleNavigator_v1.0
Реализация библиотеки s21_graph для Ubuntu/Macos

![](https://github.com/Apsaraconda/SimpleNavigator_v1.0/blob/main/misc/gif/preview.gif)

## Основные свойства:
Графы должны соответствовать следующим требованиям:
- Веса ребер должны быть только натуральными числами.
- Могут быть циклы.
- Веса могут быть разными на всех ребрах.
- Только ненулевой связный граф.

Реализация библиотеки s21_graph:

* Библиотека разработана на языке C++ стандарта C++17.
* Библиотека представлена ​​в виде класса `Graph`, который хранит информацию о графе с помощью **матрицы смежности**.
* Программа собирается с помощью Makefile.

* Класс `Graph` содержит следующие публичные методы:
+ `LoadGraphFromFile(string filename)` — загрузка графа из файла в формате матрицы смежности.
+ `ExportGraphToDot(string filename)` — экспорт графа в dot-файл.

Реализация библиотеки s21_graph_algorithms:
* Библиотека разработана на языке C++ стандарта C++17.
* Класс ` GraphAlgorithms ` содержит следующие публичные методы:
+ `DepthFirstSearch(Graph &graph, int start_vertex)` — *нерекурсивный* поиск в глубину в графе от заданной вершины. Функция возвращает массив, содержащий пройденные вершины в порядке их обхода. При реализации этой функции использовалась *самописная* структура данных **stack**.
+ `BreadthFirstSearch(Graph &graph, int start_vertex)` — поиск в ширину в графе от заданной вершины. Функция возвращает массив, содержащий пройденные вершины в порядке их прохождения. При реализации этой функции использовалась *самописная* структура данных **queue**.
* Имеются *самописные* вспомогательные классы `Stack` и `Queue`. Эти классы содержат следующие методы:
+ `Stack()` — создание пустого стека;
+ `Queue()` — создание пустой очереди;
+ `Push(value)` — добавление элемента в стек/очередь;
+ `Pop()` — получение элемента из стека/очереди с последующим удалением его из стека/очереди;
+ `Top()` — получение элемента из стека без удаления его из стека;
+ `Front()` — получение первого элемента из очереди без удаления его из очереди;
+ `Back()` — получение последнего элемента из очереди без его удаления из очереди.

*Номера вершин начинаются с 1.*

## Поиск кратчайших путей в графе

* В классе `GraphAlgorithms` есть два метода:
+ `GetShortestPathBetweenVertices(Graph &graph, int vertex1, int vertex2)` — поиск кратчайшего пути между двумя вершинами в графе с использованием *алгоритма Дейкстры*. Функция принимает на вход номера двух вершин и возвращает числовой результат, равный наименьшему расстоянию между ними.
+ `GetShortestPathsBetweenAllVertices(Graph &graph)` — поиск кратчайших путей между всеми парами вершин в графе с использованием *алгоритма Флойда-Уоршелла*. В результате функция возвращает матрицу кратчайших путей между всеми вершинами графа.

## Поиск минимального остовного дерева

* В классе `GraphAlgorithms` есть метод:
+ `GetLeastSpanningTree(Graph &graph)` — поиск минимального остовного дерева в графе с использованием *алгоритма Прима*. В результате функция возвращает матрицу смежности для минимального остовного дерева.

## Задача коммивояжера

* В классе `GraphAlgorithms` есть метод:
+ `SolveTravelingSalesmanProblem(Graph &graph)` — решение задачи коммивояжера с использованием *алгоритма муравьиной колонии*.
Метод находит кратчайший путь, проходящий через все вершины графа хотя бы один раз, с последующим возвратом к исходной вершине. В результате функция возвращает структуру `TsmResult`, описанную ниже:
```cpp
struct TsmResult {
std::vector<int> vertices; // массив с искомым маршрутом (с порядком обхода вершин).
double distance; // длина этого маршрута
}
```

*Если невозможно решить задачу с заданным графом, программа выводит ошибку.*

## Консольный интерфейс

* Основная программа представляет собой консольное приложение для проверки функциональности реализованных библиотек s21_graph и s21_graph_algorithms.
* Консольный интерфейс предоставляет следующую функциональность:
1. Загрузить исходный граф из файла.
2. Обойти граф в ширину и вывести результат на консоль.
3. Обойти граф в глубину и вывести результат на консоль.
4. Найти кратчайший путь между любыми двумя вершинами и вывести результат на консоль.
5. Найти кратчайшие пути между всеми парами вершин в графе и вывести матрицу результата на консоль.
6. Поиск минимального остовного дерева в графе и вывод полученной матрицы смежности на консоль.
7. Решить задачу «Коммивояжёр», выведя на консоль полученный маршрут и его длину.
8. Вывести сравнение скорости решения задачи «Коммивояжёр» с использованием трёх алгоритмов: муравьиной колонии, жадного алгоритма и алгоритма грубой силы.";

## Сравнение методов решения задачи коммивояжера

* Программа может выполнять сравнение скорости трех алгоритмов (алгоритма муравьиной колонии, жадного алгоритма и алгоритма грубой силы):
+ Исследование начинается для графа, который был предварительно загружен из файла.
+ В рамках исследования программа отслеживает время, которое потребовалось для решения задачи коммивояжера `N` раз подряд, каждым из алгоритмов. Где `N` задается с клавиатуры.
+ Результаты измерения времени отображаются в консоли в микросекундах.

*Пример:* Для `N = 1000` будет измерено, сколько времени потребуется для решения задачи коммивояжера 1000 раз для текущего заданного графа с использованием алгоритма муравьиной колонии, жадного алгоритма и алгоритма грубой силы.

## Компиляция:

Требования:
+ Ubuntu или MacOS.
+ gcc v.12+.
+ make

Используйте команду "make":
```
make all
```
или
```
make app
```
## Удаление:
```
make clean
```
Или удалите приложения вручную.

## Запуск:
```
make run
```
Или вручную запустите файл "SimpleNavigator".